#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <MIDIUSB.h>
#include <EEPROM.h>
#include <usbh_midi.h>

enum MidiMode { PC, CC, SysEx1, SysEx2, PC2 };
MidiMode currentMode = CC;
const int modeEEPROMAddress = 0;

#define NUM_SWITCHES 7
#define BANKS 20
#define PATCHES_PER_BANK 4
#define MAX_CC_VALUE 127
#define MAX_PC_VALUE 127
#define MAX_CHANNEL 15
#define EEPROM_SIZE (BANKS * NUM_SWITCHES * 3) // Three arrays of elements each (CC number, ON value, OFF value) for each bank and switch
#define MODE_EEPROM_ADDRESS 0
#define CC_SETTINGS_START 1
#define PC_SETTINGS_START (CC_SETTINGS_START + EEPROM_SIZE)
// LCD instance
LiquidCrystal_I2C lcd(0x27, 16, 2);

// USB Host Shield library instances
USB Usb;
//USBHub Hub(&Usb); // Optional, in case you want to use USB hubs
USBH_MIDI midi(&Usb);

// Switch pins
const int switchPins[NUM_SWITCHES] = {4, 5, 6, 7, 8, 10, 11};

// LED pins
const int ledPins[PATCHES_PER_BANK] = {12, 13, A0, A1};

// State variables
int currentPage = 0;
bool editMode = false;
bool selectCCMode = false;
bool toggleCCOn = false;
bool toggleCCOff = false;
int selectedCC = 0;
int ccOnValue = 0;
int ccOffValue = 0;
int currentPatch = -1;
bool scrollingBanks = false;
bool editModeActive = false; // Flag to track if edit mode is active
// Three-dimensional arrays to store CC assignments, ON values, and OFF values for each bank and switch
int ccAssignments[BANKS][NUM_SWITCHES] = {{0}};
int ccOnValues[BANKS][NUM_SWITCHES] = {{0}};
int ccOffValues[BANKS][NUM_SWITCHES] = {{0}};
// For PC2 mode
int pcChannels[BANKS][PATCHES_PER_BANK] = {{0}}; // MIDI channels (0-15)
int pcNumbers[BANKS][PATCHES_PER_BANK] = {{0}};  // PC numbers (0-127)
int pcOffNumbers[BANKS][PATCHES_PER_BANK] = {{0}}; // PC numbers for OFF state (0-127)

// Button press handling variables
unsigned long buttonPressTimes[NUM_SWITCHES] = {0};
bool longPressHandled[NUM_SWITCHES] = {false};
bool toggleState[BANKS][PATCHES_PER_BANK] = {false};
bool buttonPressed[NUM_SWITCHES] = {false};

int lastButtonIndex = -1;

void setup() {
  Serial.begin(115200); // For debugging

  // Initialize switches
  for (int i = 0; i < NUM_SWITCHES; i++) {
    pinMode(switchPins[i], INPUT_PULLUP);
  }

  // Initialize LEDs
  for (int i = 0; i < PATCHES_PER_BANK; i++) {
    pinMode(ledPins[i], OUTPUT);
    digitalWrite(ledPins[i], LOW);
  }

  // Initialize LCD
  lcd.init();
  lcd.backlight();

  // Display startup message
  lcd.print("RAIZO 6M");
  delay(1500);
  lcd.clear();

  // Display initial patch
  currentPage = 0;   // Default to bank 1
  currentPatch = 0;  // Default to patch A
  displayPatchName(currentPatch, false);
      
  // Read mode from EEPROM
  int modeFromEEPROM = EEPROM.read(modeEEPROMAddress);
  if (modeFromEEPROM >= 1 && modeFromEEPROM <= 5) {
    currentMode = static_cast<MidiMode>(modeFromEEPROM - 1); // Convert stored value to MidiMode enum
  } else {
    currentMode = CC; // Default to CC mode if EEPROM value is invalid
  }
  // Load settings from EEPROM
  loadSettingsFromEEPROM();
  loadPC2SettingsFromEEPROM();

  // Initialize USB host shield
  if (Usb.Init() == -1) {
    // Serial.println("USB Host Shield initialization failed");
    while (1); // Halt
  }
  // Serial.println("USB Host Shield initialized");
}

void loop() {
  Usb.Task(); // Handle USB tasks

  static bool usbHostEnabled = true; // Track USB Host Shield state
  static bool deviceConnected = false; // Track connection status

  // Check USB Host Shield status
  if (usbHostEnabled) {
    if (midi) { // If a device is connected
      if (!deviceConnected) {
        deviceConnected = true;
        lcd.clear();
        lcd.print("Device Connected");
        delay(1500); // Briefly show connection status
        lcd.clear();
        displayPatchName(currentPatch, toggleState[currentPage][currentPatch]);
      }
    } else { // No device connected
      if (deviceConnected) {
        deviceConnected = false;
        lcd.clear();
        lcd.print("Device Removed");
        delay(1500);
        lcd.clear();

      // Display initial patch
        currentPage = 0;   // Default to bank 1
        currentPatch = 0;  // Default to patch A
        displayPatchName(currentPatch, false);
      }
    }
  } else { // USB Host Shield is disabled
    if (deviceConnected) {
      deviceConnected = false; // Reset connection status
      lcd.clear();
      displayPatchName(currentPatch, toggleState[currentPage][currentPatch]);
    }
  }

  // Handle button presses
  for (int i = 0; i < NUM_SWITCHES; i++) {
    if (digitalRead(switchPins[i]) == LOW) {
      handleButtonPress(i);
      delay(150); // Debounce delay
    } else {
      buttonPressTimes[i] = millis();
      longPressHandled[i] = false;
      buttonPressed[i] = false;
    }
  }
}

void handleButtonPress(int buttonIndex) {
  if (buttonIndex == 5 && !editMode) {
    // Cycle through modes (PC, CC, SysEx1, SysEx2, PC2)
    currentMode = static_cast<MidiMode>((currentMode + 1) % 5);

    // Save current mode to EEPROM
    EEPROM.write(modeEEPROMAddress, currentMode + 1);

    // Display the current mode on LCD
    lcd.clear();
    lcd.print(currentMode == PC ? "MODE 1 PC" : 
               (currentMode == CC) ? "MODE 2 CC" : 
               (currentMode == SysEx1) ? "MODE 3 bossgt1" : 
               (currentMode == SysEx2) ? "MODE 4 bossgt1b" : "MODE 5 g1x4");
    return;
  }

  if (!longPressHandled[buttonIndex] && (millis() - buttonPressTimes[buttonIndex]) >= 2000) { // Long press detected
    if (!editMode && buttonIndex >= 0 && buttonIndex <= 3) {
      lcd.clear();
      if (currentMode == PC2) {
        lcd.print("CHNL: ");
      } else {
        lcd.print("EDIT: ");
      }
      selectCCMode = true;
      editMode = true;
      currentPatch = buttonIndex;
      blinkLED(buttonIndex, 500); // Blink LED slowly during edit mode
    } else if (editMode && buttonIndex == 5) { // Long press on button 6 to save assigned values
      exitEditMode(); // Save assigned values and exit edit mode
    }
    longPressHandled[buttonIndex] = true;
  } else if (editMode) {
    if (buttonIndex == 5) { // Button 6 used for editing and saving
      if (currentMode == PC2) {
        if (selectCCMode) {
          selectCCMode = false;
          toggleCCOn = true;
          lcd.clear();
          lcd.print("CHNL: ");
          lcd.print(pcChannels[currentPage][currentPatch]);
        } else if (toggleCCOn) {
          toggleCCOn = false;
          toggleCCOff = true;
          lcd.clear();
          lcd.print("ON: ");
          lcd.print(pcNumbers[currentPage][currentPatch]);
        } else if (toggleCCOff) {
          toggleCCOff = false;
          lcd.clear();
          lcd.print("OFF: ");
          lcd.print(pcOffNumbers[currentPage][currentPatch]);
        } else {
          exitEditMode();
        }
      } else {
        if (selectCCMode) {
          selectCCMode = false;
          toggleCCOn = true;
          lcd.clear();
          lcd.print("ON: ");
          lcd.print(ccOnValue);
        } else if (toggleCCOn) {
          toggleCCOn = false;
          toggleCCOff = true;
          lcd.clear();
          lcd.print("OFF: ");
          lcd.print(ccOffValue);
        } else if (toggleCCOff) {
          toggleCCOff = false;
          exitEditMode();
        }
      }
    } else if (buttonIndex == 2) { // Button 2 used to scroll down values
      if (currentMode == PC2) {
        if (selectCCMode) {
          pcChannels[currentPage][currentPatch] = (pcChannels[currentPage][currentPatch] == 0) ? MAX_CHANNEL : pcChannels[currentPage][currentPatch] - 1;
          lcd.setCursor(6, 0);
          lcd.print("   ");
          lcd.setCursor(6, 0);
          lcd.print(pcChannels[currentPage][currentPatch]);
        } else if (toggleCCOn) {
          pcNumbers[currentPage][currentPatch] = (pcNumbers[currentPage][currentPatch] == 0) ? MAX_PC_VALUE : pcNumbers[currentPage][currentPatch] - 1;
          lcd.setCursor(4, 0);
          lcd.print("   ");
          lcd.setCursor(4, 0);
          lcd.print(pcNumbers[currentPage][currentPatch]);
        } else if (toggleCCOff) {
          pcOffNumbers[currentPage][currentPatch] = (pcOffNumbers[currentPage][currentPatch] == 0) ? MAX_PC_VALUE : pcOffNumbers[currentPage][currentPatch] - 1;
          lcd.setCursor(5, 0);
          lcd.print("   ");
          lcd.setCursor(5, 0);
          lcd.print(pcOffNumbers[currentPage][currentPatch]);
        }
      } else {
        if (selectCCMode) {
          selectedCC = (selectedCC == 0) ? MAX_CC_VALUE : selectedCC - 1;
          lcd.setCursor(6, 0);
          lcd.print("   ");
          lcd.setCursor(6, 0);
          lcd.print(selectedCC);
        } else if (toggleCCOn) {
          ccOnValue = (ccOnValue == 0) ? MAX_CC_VALUE : ccOnValue - 1;
          lcd.setCursor(4, 0);
          lcd.print("   ");
          lcd.setCursor(4, 0);
          lcd.print(ccOnValue);
        } else if (toggleCCOff) {
          ccOffValue = (ccOffValue == 0) ? MAX_CC_VALUE : ccOffValue - 1;
          lcd.setCursor(5, 0);
          lcd.print("   ");
          lcd.setCursor(5, 0);
          lcd.print(ccOffValue);
        }
      }
    } else if (buttonIndex == 3) { // Button 3 used to scroll up values
      if (currentMode == PC2) {
        if (selectCCMode) {
          pcChannels[currentPage][currentPatch] = (pcChannels[currentPage][currentPatch] == MAX_CHANNEL) ? 0 : pcChannels[currentPage][currentPatch] + 1;
          lcd.setCursor(6, 0);
          lcd.print("   ");
          lcd.setCursor(6, 0);
          lcd.print(pcChannels[currentPage][currentPatch]);
        } else if (toggleCCOn) {
          pcNumbers[currentPage][currentPatch] = (pcNumbers[currentPage][currentPatch] == MAX_PC_VALUE) ? 0 : pcNumbers[currentPage][currentPatch] + 1;
          lcd.setCursor(4, 0);
          lcd.print("   ");
          lcd.setCursor(4, 0);
          lcd.print(pcNumbers[currentPage][currentPatch]);
        } else if (toggleCCOff) {
          pcOffNumbers[currentPage][currentPatch] = (pcOffNumbers[currentPage][currentPatch] == MAX_PC_VALUE) ? 0 : pcOffNumbers[currentPage][currentPatch] + 1;
          lcd.setCursor(5, 0);
          lcd.print("   ");
          lcd.setCursor(5, 0);
          lcd.print(pcOffNumbers[currentPage][currentPatch]);
        }
      } else {
        if (selectCCMode) {
          selectedCC = (selectedCC == MAX_CC_VALUE) ? 0 : selectedCC + 1;
          lcd.setCursor(6, 0);
          lcd.print("   ");
          lcd.setCursor(6, 0);
          lcd.print(selectedCC);
        } else if (toggleCCOn) {
          ccOnValue = (ccOnValue == MAX_CC_VALUE) ? 0 : ccOnValue + 1;
          lcd.setCursor(4, 0);
          lcd.print("   ");
          lcd.setCursor(4, 0);
          lcd.print(ccOnValue);
        } else if (toggleCCOff) {
          ccOffValue = (ccOffValue == MAX_CC_VALUE) ? 0 : ccOffValue + 1;
          lcd.setCursor(5, 0);
          lcd.print("   ");
          lcd.setCursor(5, 0);
          lcd.print(ccOffValue);
        }
      }
    }
  } else {
    if (buttonIndex == 4) {
      // Next Page button pressed
      if (currentPage < BANKS - 1) {
        currentPage++;
        scrollingBanks = true;
        displayPage(currentPage);
        turnOffAllLEDs(); // Turn off LEDs when scrolling banks
        lastButtonIndex = -1; // Reset last button when changing banks
      }
    } else if (buttonIndex == 6) {
      // Previous Page button pressed
      if (currentPage > 0) {
        currentPage--;
        scrollingBanks = true;
        displayPage(currentPage);
        turnOffAllLEDs(); // Turn off LEDs when scrolling banks
        lastButtonIndex = -1; // Reset last button when changing banks
      }
    } else if (buttonIndex >= 0 && buttonIndex <= 3) {
      if (!buttonPressed[buttonIndex]) { // Manual debounce for patch buttons
        buttonPressed[buttonIndex] = true;
        int pcValue = (currentPage * 4) + buttonIndex; 
        int presetID = (currentPage * 4) + buttonIndex;
        int preset = (currentPage * 4) + buttonIndex;
        
        if (lastButtonIndex == buttonIndex) {
          // Same button pressed, toggle its state
          toggleState[currentPage][buttonIndex] = !toggleState[currentPage][buttonIndex];
          if (toggleState[currentPage][buttonIndex]) {
            if (currentMode == PC) {
              sendMIDIProgramChange(0, pcValue); 
            } else if (currentMode == SysEx1) {
              sendSysEx(presetID, (byte)(127 - presetID));
            } else if (currentMode == SysEx2) {
              sendSysEx1(preset, (byte)(127 - preset));
            } else if (currentMode == PC2) {
              sendMIDIProgramChange1( pcChannels[currentPage][buttonIndex], pcNumbers[currentPage][buttonIndex]/*, true*/);
            } else {
              sendMIDIControlChange(0, ccAssignments[currentPage][buttonIndex], ccOnValues[currentPage][buttonIndex]);
            }
            digitalWrite(ledPins[buttonIndex], HIGH);
            displayPatchName(buttonIndex, true);
          } else {
            if (!scrollingBanks) { 
              if (currentMode == SysEx1) {
                sendSysEx(presetID, (byte)(127 - presetID));
              } else if (currentMode == SysEx2) {
                sendSysEx1(preset, (byte)(127 - preset));
              } else if (currentMode == PC) {
                sendMIDIProgramChange(0, pcValue);
              } else if (currentMode == PC2) {
                sendMIDIProgramChange1( pcChannels[currentPage][buttonIndex], pcOffNumbers[currentPage][buttonIndex]/*, false*/);
              } else {
                sendMIDIControlChange(0, ccAssignments[currentPage][buttonIndex], ccOffValues[currentPage][buttonIndex]);
              }
            }
            digitalWrite(ledPins[buttonIndex], LOW);
            displayPatchName(buttonIndex, false);
          }
        } else {
          // Different button pressed, reset toggle state and turn off previous LED
          if (lastButtonIndex != -1) {
            toggleState[currentPage][lastButtonIndex] = false;
            digitalWrite(ledPins[lastButtonIndex], LOW);
          }
          lastButtonIndex = buttonIndex;

          // Set the new button state to ON
          toggleState[currentPage][buttonIndex] = true;
          if (currentMode == PC) {
            sendMIDIProgramChange(0, pcValue);
          } else if (currentMode == SysEx1) {
            sendSysEx(presetID, (byte)(127 - presetID));
          } else if (currentMode == SysEx2) {
            sendSysEx1(preset, (byte)(127 - preset));
          } else if (currentMode == PC2) {
            sendMIDIProgramChange1( pcChannels[currentPage][buttonIndex], pcNumbers[currentPage][buttonIndex]/*, true*/);
          } else {
            sendMIDIControlChange(0, ccAssignments[currentPage][buttonIndex], ccOnValues[currentPage][buttonIndex]);
          }
          digitalWrite(ledPins[buttonIndex], HIGH);
          displayPatchName(buttonIndex, true);
        }
      }
    }
  }

  // Handle scrolling banks if required
  if (scrollingBanks) {
    scrollingBanks = false;
  }
}

void displayPatchName(int buttonIndex, bool toggleOn) {
  lcd.clear();
  switch (buttonIndex) {
    case 0:
      lcd.print("PATCH A");
      break;
    case 1:
      lcd.print("PATCH B");
      break;
    case 2:
      lcd.print("PATCH C");
      break;
    case 3:
      lcd.print("PATCH D");
      break;
  }
  lcd.setCursor(0, 1);  // Move the cursor to the second line
  lcd.print("BANK ");
  lcd.print(currentPage + 1);  // Display the current bank number

  // Display ON/OFF CC indicator
  lcd.setCursor(13, 0);  // Move cursor to column 13 of the first line
  lcd.print(toggleOn ? "ON" : "OFF");
}

void displayPage(int page) {
  lcd.clear();
  lcd.print("BANK ");
  lcd.print(page + 1);
  lcd.setCursor(0, 1);
}

void exitEditMode() {
  if (currentPatch != -1) {
    if (currentMode == PC2) {
      // In PC2 mode, we've been editing pcChannels, pcNumbers, and pcOffNumbers directly
      // No need to store anything here as they're already updated in the arrays
    } else {
      // Store adjustable CC values for the current patch
      ccAssignments[currentPage][currentPatch] = selectedCC;
      ccOnValues[currentPage][currentPatch] = ccOnValue;
      ccOffValues[currentPage][currentPatch] = ccOffValue;
    }

    // Save settings to EEPROM
    saveSettingsToEEPROM();
  }

  selectCCMode = false;
  toggleCCOn = false;
  toggleCCOff = false;
  editMode = false;
  currentPatch = -1;
  lcd.clear();
  lcd.print("SAVE!");

  // Blink all LEDs rapidly for 2 seconds to indicate saving
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < PATCHES_PER_BANK; j++) {
      digitalWrite(ledPins[j], HIGH);
    }
    delay(50);
    for (int j = 0; j < PATCHES_PER_BANK; j++) {
      digitalWrite(ledPins[j], LOW);
    }
    delay(50);
  }
  
  // Display initial patch
  currentPage = 0;   // Default to bank 1
  currentPatch = 0;  // Default to patch A
  displayPatchName(currentPatch, false);
}

void blinkLED(int ledIndex, int interval) {
  unsigned long currentMillis = millis();
  static unsigned long previousMillis[PATCHES_PER_BANK] = {0};
  static bool ledState[PATCHES_PER_BANK] = {false};

  if (currentMillis - previousMillis[ledIndex] >= interval) {
    previousMillis[ledIndex] = currentMillis;
    ledState[ledIndex] = !ledState[ledIndex];
    digitalWrite(ledPins[ledIndex], ledState[ledIndex] ? HIGH : LOW);
  }
}

void sendMIDIControlChange(byte channel, byte control, byte value) {
  uint8_t status = 0xB0 | (channel & 0x0F);
  uint8_t data[3] = {status, control, value};

  // Send the MIDI message through the USB host shield
  midi.SendData(data, 3);

  // Also send the MIDI message via USB MIDI to PC
  midiEventPacket_t event = {0x0B, status, control, value};
  MidiUSB.sendMIDI(event);
  MidiUSB.flush();
}

void sendMIDIProgramChange(byte channel, byte program) {
  uint8_t status = 0xC0 | (channel & 0x0F);
  uint8_t data[3] = {status, program};

  // Send the MIDI message through the USB host shield
  midi.SendData(data, 3);

  // Also send the MIDI message via USB MIDI to PC
  midiEventPacket_t event = {0x0C, status, program, 0};
  MidiUSB.sendMIDI(event);
  MidiUSB.flush();
}

void sendSysEx(int presetID, bool toggleOn) {
  byte msg[] = { 0xF0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x01, 0x00, 0x00, 0x00, (byte)presetID, (byte)(127 - presetID), 0xF7 };
  midi.SendData(msg, sizeof(msg));
  // Also send the SysEx message via USB MIDI to PC
  midiEventPacket_t event = {0x09, msg[0], msg[1], msg[2]}; // SysEx event
  MidiUSB.sendMIDI(event);
  for (int i = 3; i < sizeof(msg); i += 3) {
    event = {0x07, msg[i], msg[i + 1], msg[i + 2]}; // SysEx continuation event
    MidiUSB.sendMIDI(event);
  }
  MidiUSB.flush();
}

void sendSysEx1(int preset, bool toggleOn) {
  byte msg[] = { 0xF0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x30, 0x12, 0x01, 0x00, 0x00, 0x00, (byte)preset, (byte)(127 - preset), 0xF7 };
  midi.SendData(msg, sizeof(msg));
  // Also send the SysEx message via USB MIDI to PC
  midiEventPacket_t event = {0x09, msg[0], msg[1], msg[2]}; // SysEx event
  MidiUSB.sendMIDI(event);
  for (int i = 3; i < sizeof(msg); i += 3) {
    event = {0x07, msg[i], msg[i + 1], msg[i + 2]}; // SysEx continuation event
    MidiUSB.sendMIDI(event);
  }
  MidiUSB.flush();
}

void sendMIDIProgramChange1(byte channel, byte program) {
  uint8_t status = 0xC0 | (channel & 0x0F);
  uint8_t data[2] = {status, program};

  // Send the MIDI message through the USB host shield
  midi.SendData(data, 2);

  // Also send the MIDI message via USB MIDI to PC
  midiEventPacket_t event = {0x0C, status, program};
  MidiUSB.sendMIDI(event);
  MidiUSB.flush();
}

void saveSettingsToEEPROM() {
  int startAddress = (currentMode == CC) ? CC_SETTINGS_START : PC_SETTINGS_START;
  
  for (int bank = 0; bank < BANKS; bank++) {
    for (int switchIndex = 0; switchIndex < NUM_SWITCHES; switchIndex++) {
      // Calculate EEPROM address for current bank, switch, and CC assignment
      int baseAddress = (bank * NUM_SWITCHES + switchIndex) * 3;
      EEPROM.write(startAddress + baseAddress, ccAssignments[bank][switchIndex]);
      EEPROM.write(startAddress + baseAddress + 1, ccOnValues[bank][switchIndex]);
      EEPROM.write(startAddress + baseAddress + 2, ccOffValues[bank][switchIndex]);
    }
  }
  
  // Save PC2 settings if in PC2 mode
  if (currentMode == PC2) {
    savePC2SettingsToEEPROM();
  }
}

void loadSettingsFromEEPROM() {
  int startAddress = (currentMode == CC) ? CC_SETTINGS_START : PC_SETTINGS_START;
  for (int bank = 0; bank < BANKS; bank++) {
    for (int switchIndex = 0; switchIndex < NUM_SWITCHES; switchIndex++) {
      // Calculate EEPROM address for current bank, switch, and CC assignment
      int baseAddress = (bank * NUM_SWITCHES + switchIndex) * 3;
      ccAssignments[bank][switchIndex] = EEPROM.read(startAddress + baseAddress);
      ccOnValues[bank][switchIndex] = EEPROM.read(startAddress + baseAddress + 1);
      ccOffValues[bank][switchIndex] = EEPROM.read(startAddress + baseAddress + 2);
    }
  }
}

void savePC2SettingsToEEPROM() {
  // Use a different EEPROM section for PC2 settings (after the CC and PC settings)
  int startAddress = PC_SETTINGS_START + EEPROM_SIZE;
  
  for (int bank = 0; bank < BANKS; bank++) {
    for (int patch = 0; patch < PATCHES_PER_BANK; patch++) {
      int baseAddress = (bank * PATCHES_PER_BANK + patch) * 3; // Now using 3 bytes per patch (channel, PC on, PC off)
      EEPROM.write(startAddress + baseAddress, pcChannels[bank][patch]);
      EEPROM.write(startAddress + baseAddress + 1, pcNumbers[bank][patch]);
      EEPROM.write(startAddress + baseAddress + 2, pcOffNumbers[bank][patch]);
    }
  }
}

void loadPC2SettingsFromEEPROM() {
  // Load from the same section where we saved PC2 settings
  int startAddress = PC_SETTINGS_START + EEPROM_SIZE;
  
  for (int bank = 0; bank < BANKS; bank++) {
    for (int patch = 0; patch < PATCHES_PER_BANK; patch++) {
      int baseAddress = (bank * PATCHES_PER_BANK + patch) * 3; // Now using 3 bytes per patch
      pcChannels[bank][patch] = EEPROM.read(startAddress + baseAddress);
      pcNumbers[bank][patch] = EEPROM.read(startAddress + baseAddress + 1);
      pcOffNumbers[bank][patch] = EEPROM.read(startAddress + baseAddress + 2);
    }
  }
}

void turnOffAllLEDs() {
  for (int i = 0; i < PATCHES_PER_BANK; i++) {
    digitalWrite(ledPins[i], LOW); // Turn off all LEDs
  }
}